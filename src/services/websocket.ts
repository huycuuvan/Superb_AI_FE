import { toast } from "react-hot-toast";

interface WebSocketMessage {
  type: string;
  payload: unknown;
}

type MessageHandler = (data: unknown) => void;

type ConnectionState = "connecting" | "open" | "closed" | "error";
type StateChangeListener = (state: ConnectionState) => void;

class WebSocketService {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectTimeout = 3000;
  private messageHandlers: Map<string, MessageHandler[]> = new Map();
  private currentWsUrl: string | null = null;
  private connectionState: ConnectionState = "closed";
  private stateChangeListeners: StateChangeListener[] = [];

  constructor() {
    console.log("Kh·ªüi t·∫°o WebSocket service...");
  }

  private setConnectionState(state: ConnectionState) {
    this.connectionState = state;
    console.log("WebSocket state changed:", state);
    this.stateChangeListeners.forEach((listener) => listener(state));
  }

  public subscribeToStateChange(listener: StateChangeListener) {
    this.stateChangeListeners.push(listener);
    listener(this.connectionState); // Notify immediately of current state
  }

  public unsubscribeFromStateChange(listener: StateChangeListener) {
    this.stateChangeListeners = this.stateChangeListeners.filter(
      (l) => l !== listener
    );
  }

  public connect(url: string) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      console.log("WebSocket ƒë√£ k·∫øt n·ªëi, b·ªè qua y√™u c·∫ßu k·∫øt n·ªëi m·ªõi.");
      this.setConnectionState("open");
      if (this.currentWsUrl !== url) {
        this.disconnect();
        this.connect(url);
      }
      return;
    }
    if (this.ws?.readyState === WebSocket.CONNECTING) {
      console.log("WebSocket ƒëang k·∫øt n·ªëi, b·ªè qua y√™u c·∫ßu k·∫øt n·ªëi m·ªõi.");
      if (this.currentWsUrl !== url) {
        this.disconnect();
        this.connect(url);
      }
      this.setConnectionState("connecting");
      return;
    }

    this.currentWsUrl = url;
    this.setConnectionState("connecting");

    try {
      console.log("ƒêang k·∫øt n·ªëi ƒë·∫øn WebSocket server:", this.currentWsUrl);

      this.ws = new WebSocket(this.currentWsUrl);

      this.ws.onopen = () => {
        console.log("‚úÖ WebSocket ƒë√£ k·∫øt n·ªëi th√†nh c√¥ng");
        this.reconnectAttempts = 0;
        this.setConnectionState("open");
      };

      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data) as WebSocketMessage;
          console.log("üì• Nh·∫≠n tin nh·∫Øn WebSocket:", data);

          const { type, payload } = data;
          if (this.messageHandlers.has(type)) {
            console.log(`üîÑ X·ª≠ l√Ω tin nh·∫Øn lo·∫°i: ${type}`);
            this.messageHandlers
              .get(type)
              ?.forEach((handler) => handler(payload));
          } else {
            console.log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y handler cho lo·∫°i tin nh·∫Øn: ${type}`);
          }
        } catch (error) {
          console.error("‚ùå L·ªói khi x·ª≠ l√Ω tin nh·∫Øn WebSocket:", error);
        }
      };

      this.ws.onclose = (event) => {
        console.log("üîå WebSocket ƒë√£ ƒë√≥ng k·∫øt n·ªëi:", event.code, event.reason);
        this.setConnectionState("closed");
        if (this.currentWsUrl) {
          this.handleReconnect();
        }
      };

      this.ws.onerror = (error) => {
        console.error("‚ùå L·ªói WebSocket:", error);
        this.setConnectionState("error");
      };
    } catch (error) {
      console.error("‚ùå L·ªói khi k·∫øt n·ªëi WebSocket:", error);
      this.setConnectionState("error");
      if (this.currentWsUrl) {
        this.handleReconnect();
      } else {
        toast.error("Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß. Vui l√≤ng th·ª≠ l·∫°i sau.");
      }
    }
  }

  private handleReconnect() {
    if (!this.currentWsUrl) return;

    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(
        `üîÑ ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i l·∫ßn ${this.reconnectAttempts}/${this.maxReconnectAttempts}`
      );
      setTimeout(() => {
        if (this.currentWsUrl) {
          this.setConnectionState("connecting");
          this.connect(this.currentWsUrl);
        }
      }, this.reconnectTimeout);
    } else {
      console.error("‚ùå ƒê√£ v∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠ k·∫øt n·ªëi l·∫°i");
      toast.error("Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß. Vui l√≤ng th·ª≠ l·∫°i sau.");
    }
  }

  public subscribe(type: string, handler: MessageHandler) {
    console.log(`üìù ƒêƒÉng k√Ω l·∫Øng nghe s·ª± ki·ªán: ${type}`);
    if (!this.messageHandlers.has(type)) {
      this.messageHandlers.set(type, []);
    }
    this.messageHandlers.get(type)?.push(handler);
  }

  public unsubscribe(type: string, handler: MessageHandler) {
    console.log(`üîï H·ªßy ƒëƒÉng k√Ω s·ª± ki·ªán: ${type}`);
    if (this.messageHandlers.has(type)) {
      const handlers = this.messageHandlers.get(type) || [];
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  public send(messageObject: unknown) {
    console.log(`üì§ G·ª≠i tin nh·∫Øn WebSocket:`, messageObject);
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(messageObject));
    } else {
      console.error("‚ùå Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn - WebSocket ch∆∞a k·∫øt n·ªëi");
      toast.error(
        "Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn. K·∫øt n·ªëi WebSocket ƒë√£ ƒë√≥ng ho·∫∑c ƒëang trong qu√° tr√¨nh k·∫øt n·ªëi l·∫°i."
      );
    }
  }

  public disconnect() {
    console.log("üîå ƒê√≥ng k·∫øt n·ªëi WebSocket");
    if (this.ws) {
      this.currentWsUrl = null;
      this.setConnectionState("closed");
      this.ws.close();
      this.ws = null;
    }
  }

  public getReadyState(): number | undefined {
    return this.ws?.readyState;
  }

  public getConnectionState(): ConnectionState {
    return this.connectionState;
  }
}

export const websocketService = new WebSocketService();
